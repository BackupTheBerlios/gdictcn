/*
 * gtk-terminal 
 * Author: Dave Young <lonelypenguin@gmail.com> 
 *
 * This software is released under the GNU General Public License (GNU GPL).
 * Please read the included file COPYING for more information.
 * This software comes with no warranty of any kind, use at your own risk!
 */


#include "gtk-terminal.h"
#include "rcfile.h"
#include "util.h"

static gchar * rcfile_path(void)
{
  	gchar *path = NULL;
  	const gchar *home_dir;

  	home_dir = (gchar *)get_home_dir ();
  	if (home_dir){
      		path = g_build_filename (home_dir,RCFILE, NULL);
	}

	g_free((gpointer)home_dir);
	return path;
}

/*
 * line write/parse routines
 */ 

gchar *quoted_value(const gchar *text)
{
	const gchar *ptr;
	gint i = 0;
	gint len = strlen(text);

	if (len == 0) return NULL;

	while (i < len && text[i] !='"') i++;
	if (text[i] == '"'){
		gint j;
		i++;
		ptr = text + i;
		j = i;
		while (j < len && text[j] !='"') j++;
		if (text[j] == '"'){
			if (j - i > 0)
				return g_strndup(ptr, j - i);
		}
	}
	return NULL;
}

static void write_char_option(FILE *f, gchar *label, gchar *text)
{
	if (text)
		fprintf(f,"%s: \"%s\"\n", label, text);
	else
		fprintf(f,"%s: \n", label);
}

static gchar *read_char_option(FILE *f, gchar *option, gchar *label, gchar *value)
{
	if (strcasecmp(option, label) == 0){
		return value;
	}
	return NULL;
}

static void write_int_option(FILE *f, gchar *label, gint n)
{
	fprintf(f,"%s: \"%d\"\n", label, n);
}

static gint read_int_option(FILE *f, gchar *option, gchar *label, gchar *value)
{
	gint vaint;

	vaint=atoi(value);
	
	if (strcasecmp(option, label) == 0){
		g_free(value);
		return vaint;
	}
	return -1;
}

static void write_bool_option(FILE *f, gchar *label, gboolean bol)
{
	if(bol)
		fprintf(f,"%s: \"TRUE\"\n", label);
	else
		fprintf(f,"%s: \"FALSE\"\n", label);
}

static gint read_bool_option(FILE *f,gchar *option, gchar *label, gchar *value , gboolean * bol)
{
	if (strcasecmp(option, label) == 0){
		if(strncmp(value,"TRUE",4))
			*bol=FALSE;
		else
			*bol=TRUE;
		return 0;
	}
	return 1;
}

/*
 * save configuration
 */ 

void save_options(confinfo * cf)
{
	FILE *f;
	gchar *rc_path;

	rc_path = rcfile_path();

	if(!rc_path)
		return;

	f = fopen(rc_path, "w");
	g_free(rc_path);

	if (!f){
		g_print(_("error saving config file: %s\n"), rc_path);
		return;
	}

	fprintf(f,"#%%$*gtk-terminal config file\n");
	fprintf(f,"\n");
	fprintf(f,"# Note: This file is autogenerated. Options can be changed here,\n");
	fprintf(f,"#       but user comments and formatting will be lost.\n");
	fprintf(f,"\n");

	write_char_option(f, "fontname", cf->fontname);
	write_char_option(f, "charset", cf->charset);
	write_int_option(f, "fg_red", cf->fg_red);
	write_int_option(f, "fg_green", cf->fg_green);
	write_int_option(f, "fg_blue", cf->fg_blue);
	write_int_option(f, "bg_red", cf->bg_red);
	write_int_option(f, "bg_green", cf->bg_green);
	write_int_option(f, "bg_blue", cf->bg_blue);
	write_bool_option(f, "allow_bold", cf->allow_bold);
	write_bool_option(f, "bell", cf->bell);
	write_bool_option(f, "cursor_blinks", cf->cursor_blinks);
	write_bool_option(f, "scroll_output", cf->scroll_output);
	write_bool_option(f, "scroll_key", cf->scroll_key);
	write_int_option(f, "scrollback_lines", cf->scrollback_lines);
	write_char_option(f, "word_chars", cf->word_chars);
	write_int_option(f, "backspace_style", cf->backspace_style);
	write_int_option(f, "delete_style", cf->delete_style);

	fprintf(f,"\n");
	fprintf(f,"#%%$*gtk-terminal config file\n");
	fclose(f);
}

/*
 *-----------------------------------------------------------------------------
 * load configuration (public)
 *-----------------------------------------------------------------------------
 */ 

void load_options(confinfo *cf)
{
	FILE *f;
	gchar *rc_path;
	gchar s_buf[1024];
	gchar *s_buf_ptr;
	gchar * tmp;
	gchar option[1024]={'0',};
	gchar value[1024]={'0',};
	gchar * va=NULL;
	gint i,j,len,size;
	gchar * fontname=NULL;
	gchar * charset=NULL;
	gint fg_red=-1,fg_green=-1,fg_blue=-1,bg_red=-1,bg_green=-1,bg_blue=-1;
	gboolean allow_bold,bell,cursor_blinks,scroll_output,scroll_key;
	gint scrollback_lines=-1,backspace_style=-1,delete_style=-1;
	gchar * word_chars=NULL;
	
	rc_path = rcfile_path();

	if(!rc_path)
		return;

      	if (!g_file_test (rc_path, G_FILE_TEST_EXISTS)){
	 	g_free (rc_path);
		return;
	}

	f = fopen(rc_path,"r");
	g_free(rc_path);

	if (!f)
		return;

	while (fgets(s_buf,1024,f)){
		if (s_buf[0]=='#') {
			continue;
		}
		if (s_buf[0]=='\n') continue;
		i=j=0;
		len=strlen(s_buf);
		while(s_buf[i]==' ' || s_buf[i] =='\t')i++;
		j=i;
		tmp=s_buf+i;
		while(s_buf[j]!=':')j++;
		memset(option,0,sizeof(option));
		memset(value,0,sizeof(value));
		strncpy(option,tmp,j-i);
		s_buf_ptr= s_buf+j;
		strncpy(value,s_buf_ptr,strlen(s_buf_ptr));
		va = quoted_value(value);
		if(!va)
			continue;

		if(!fontname){
			fontname = read_char_option(f, option,"fontname", va);
			if(fontname)
				continue;
		}
		if(!charset){
			charset = read_char_option(f, option,"charset", va);
			if(charset)
				continue;
		}
		if(fg_red == -1){
			fg_red = read_int_option(f, option,"fg_red", va);
			if(fg_red!=-1){
				cf->fg_red=fg_red;
				continue;
			}
		}
		if(fg_green == -1){
			fg_green= read_int_option(f, option,"fg_green", va);
			if(fg_green!=-1){
				cf->fg_green=fg_green;
				continue;
			}
		}
		if(fg_blue == -1){
			fg_blue = read_int_option(f, option,"fg_blue", va);
			if(fg_blue!=-1){
				cf->fg_blue=fg_blue;
				continue;
			}
		}
		if(bg_red == -1){
			bg_red = read_int_option(f, option,"bg_red", va);
			if(bg_red!=-1){
				cf->bg_red=bg_red;
				continue;
			}
		}
		if(bg_green == -1){
			bg_green= read_int_option(f, option,"bg_green", va);
			if(bg_green!=-1){
				cf->bg_green=bg_green;
				continue;
			}
		}
		if(bg_blue == -1){
			bg_blue = read_int_option(f, option,"bg_blue", va);
			if(bg_blue!=-1){
				cf->bg_blue=bg_blue;
				continue;
			}
		}
		if(!read_bool_option(f,option,"allow_bold",va,&allow_bold)){
			cf->allow_bold=allow_bold;	
			continue;
		}
		if(!read_bool_option(f,option,"bell",va,&bell)){
			cf->bell=bell;
			continue;
		}
		if(!read_bool_option(f,option,"cursor_blinks",va,&cursor_blinks)){
			cf->cursor_blinks=cursor_blinks;
			continue;
		}
		if(!read_bool_option(f,option,"scroll_output",va,&scroll_output)){
			cf->scroll_output=scroll_output;
			continue;
		}
		if(!read_bool_option(f,option,"scroll_key",va,&scroll_key)){
			cf->scroll_key=scroll_key;	
			continue;
		}
		if(scrollback_lines == -1){
			scrollback_lines = read_int_option(f,option,"scrollback_lines",va);
			if(scrollback_lines != -1){
				cf->scrollback_lines=scrollback_lines;
				continue;
			}
		}
		if(backspace_style == -1){
			backspace_style = read_int_option(f,option,"backspace_style",va);
			if(backspace_style != -1){
				cf->backspace_style=backspace_style;
				continue;
			}
		}
		if(delete_style == -1){
			delete_style = read_int_option(f,option,"delete_style",va);
			if(delete_style != -1){
				cf->delete_style=delete_style;
				continue;
			}
		}
		if(!word_chars){
			word_chars = read_char_option(f, option,"word_chars", va);
			if(word_chars)
				continue;
		}
			
		if(va)
			g_free(va);
	}
	if(fontname){
		len=strlen(fontname);
		size=sizeof(cf->fontname);
		len=(len>size)?size:len;
		memset(cf->fontname,0,size);
		strncpy(cf->fontname,fontname,len);
		g_free(fontname);
	}
	if(charset){
		len=strlen(charset);
		size=sizeof(cf->charset);
		len=(len>size)?size:len;
		memset(cf->charset,0,size);
		strncpy(cf->charset,charset,len);
		g_free(charset);
	}
	if(word_chars){
		len=strlen(word_chars);
		size=sizeof(cf->word_chars);
		len=(len>size)?size:len;
		memset(cf->word_chars,0,size);
		strncpy(cf->word_chars,word_chars,len);
		g_free(word_chars);
	}
	
	fclose(f);
}

