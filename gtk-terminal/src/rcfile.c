/*
 * gtk-terminal 
 * Author: Dave Young <lonelypenguin@gmail.com> 
 *
 * This software is released under the GNU General Public License (GNU GPL).
 * Please read the included file COPYING for more information.
 * This software comes with no warranty of any kind, use at your own risk!
 */


#include "gtk-terminal.h"
#include "rcfile.h"

static gchar * rcfile_path(void)
{
  	gchar *path = NULL;
  	const gchar *home_dir;

  	home_dir = g_get_home_dir ();
  	if (home_dir){
      		path = g_build_filename (home_dir,RCFILE, NULL);
	}

	return path;
}

/*
 * line write/parse routines
 */ 

gchar *quoted_value(const gchar *text)
{
	const gchar *ptr;
	gint i = 0;
	gint len = strlen(text);

	if (len == 0) return NULL;

	while (i < len && text[i] !='"') i++;
	if (text[i] == '"'){
		gint j;
		i++;
		ptr = text + i;
		j = i;
		while (j < len && text[j] !='"') j++;
		if (text[j] == '"'){
			if (j - i > 0)
				return g_strndup(ptr, j - i);
		}
	}
	return NULL;
}

static void write_char_option(FILE *f, gchar *label, gchar *text)
{
	if (text)
		fprintf(f,"%s: \"%s\"\n", label, text);
	else
		fprintf(f,"%s: \n", label);
}

static gchar *read_char_option(FILE *f, gchar *option, gchar *label, gchar *value)
{
	if (strcasecmp(option, label) == 0){
		return quoted_value(value);
	}
	return NULL;
}

static void write_int_option(FILE *f, gchar *label, gint n)
{
	fprintf(f,"%s: \"%d\"\n\n", label, n);
}

static gint read_int_option(FILE *f, gchar *option, gchar *label, gchar *value)
{
	char * va;
	gint vaint;
	va=quoted_value(value);
	if(va){
		vaint=atoi(va);
		g_free(va);
	}else
		vaint=-1;
	
	if (strcasecmp(option, label) == 0)
		return vaint;
	return -1;
}


/*
 * save configuration
 */ 

void save_options(confinfo * cf)
{
	FILE *f;
	gchar *rc_path;

	rc_path = rcfile_path();

	if(!rc_path)
		return;

	f = fopen(rc_path, "w");
	g_free(rc_path);

	if (!f){
		g_print(_("error saving config file: %s\n"), rc_path);
		return;
	}

	fprintf(f,"#%%$*gtk-terminal config file\n");
	fprintf(f,"\n");
	fprintf(f,"# Note: This file is autogenerated. Options can be changed here,\n");
	fprintf(f,"#       but user comments and formatting will be lost.\n");
	fprintf(f,"\n");

	write_char_option(f, "fontname", cf->fontname);
	fprintf(f,"\n");
	write_char_option(f, "charset", cf->charset);
	fprintf(f,"\n");
	write_int_option(f, "fg_red", cf->fg_red);
	fprintf(f,"\n");
	write_int_option(f, "fg_green", cf->fg_green);
	fprintf(f,"\n");
	write_int_option(f, "fg_blue", cf->fg_blue);
	fprintf(f,"\n");
	write_int_option(f, "bg_red", cf->bg_red);
	fprintf(f,"\n");
	write_int_option(f, "bg_green", cf->bg_green);
	fprintf(f,"\n");
	write_int_option(f, "bg_blue", cf->bg_blue);
	fprintf(f,"\n");
/*
	write_bool_option(f, "layout_view_as_icons", layout_view_icons);
	write_int_option(f, "scroll_reset_method", scroll_reset_method);
*/
	fprintf(f,"#%%$*gtk-terminal config file\n");
	fclose(f);
}

/*
 *-----------------------------------------------------------------------------
 * load configuration (public)
 *-----------------------------------------------------------------------------
 */ 

void load_options(confinfo *cf)
{
	FILE *f;
	gchar *rc_path;
	gchar s_buf[1024];
	gchar *s_buf_ptr;
	gchar * tmp;
	gchar option[1024]={'0',};
	gchar value[1024]={'0',};
	gint i,j,len;
	gchar * fontname=NULL;
	gchar * charset=NULL;
	gint fg_red=-1,fg_green=-1,fg_blue=-1,bg_red=-1,bg_green=-1,bg_blue=-1;

	rc_path = rcfile_path();

	if(!rc_path)
		return;

      	if (!g_file_test (rc_path, G_FILE_TEST_EXISTS)){
	 	g_free (rc_path);
		return;
	}

	f = fopen(rc_path,"r");
	g_free(rc_path);

	if (!f)
		return;

	while (fgets(s_buf,1024,f)){
		if (s_buf[0]=='#') {
//			if(!(s_buf[1]=='%' && s_buf[2]=='$' && s_buf[3]=='*'))
//				return;
			continue;
		}
		if (s_buf[0]=='\n') continue;
		i=j=0;
		len=strlen(s_buf);
		while(s_buf[i]==' ' || s_buf[i] =='\t')i++;
		j=i;
		tmp=s_buf+i;
		while(s_buf[j]!=':')j++;
		memset(option,0,sizeof(option));
		memset(value,0,sizeof(value));
		strncpy(option,tmp,j-i);
		s_buf_ptr= s_buf+j;
		strncpy(value,s_buf_ptr,strlen(s_buf_ptr));
/*
		c = 0;
		l = strlen(s_buf);
		while (s_buf[c] != ':' && c < l) c++;
		s_buf_ptr = s_buf + c;
		//if (c >= l) continue;
		s_buf[c] = '\0';
		//c++;
		//while ((s_buf[c] == ' ' || s_buf[c] == 8) && c < l) c++;
		//s_buf_ptr = s_buf + c;
		strncpy(value_all, s_buf_ptr, sizeof(value_all));
		//while (s_buf[c] != 8 && s_buf[c] != ' ' && s_buf[c] != '\n' && c < l) c++;
		//s_buf[c] = '\0';
		strncpy(option, s_buf, sizeof(option));
		strncpy(value, s_buf_ptr, sizeof(value));
*/	
		if(!fontname){
			fontname = read_char_option(f, option,"fontname", value);
			if(fontname)
				continue;
		}
		if(!charset){
			charset = read_char_option(f, option,"charset", value);
			if(charset)
				continue;
		}
		if(fg_red == -1){
			fg_red = read_int_option(f, option,"fg_red", value);
			if(fg_red!=-1)
				continue;
		}
		if(fg_green == -1){
			fg_green= read_int_option(f, option,"fg_green", value);
			if(fg_green!=-1)
				continue;
		}
		if(fg_blue == -1){
			fg_blue = read_int_option(f, option,"fg_blue", value);
			if(fg_blue!=-1)
				continue;
		}
		if(bg_red == -1){
			bg_red = read_int_option(f, option,"bg_red", value);
			if(bg_red!=-1)
				continue;
		}
		if(bg_green == -1){
			bg_green= read_int_option(f, option,"bg_green", value);
			if(bg_green!=-1)
				continue;
		}
		if(bg_blue == -1){
			bg_blue = read_int_option(f, option,"bg_blue", value);
			if(bg_blue!=-1)
				continue;
		}
			
/*
		layout_view_tree = read_bool_option(f, option,
			"layout_view_as_tree", value, layout_view_tree);
		max_window_size = read_int_option(f, option,
			"max_window_size", value, max_window_size);
*/
	}
	if(fontname && 
			charset && 
			(fg_red !=-1) &&
			(fg_green !=-1)	&&
			(fg_blue !=-1) &&
			(bg_red !=-1) &&
			(bg_green !=-1) &&
			(bg_blue !=-1)) { 
		
		memset(cf,0,sizeof(confinfo));
		strcpy(cf->fontname,fontname);
		strcpy(cf->charset,charset);
		cf->fg_red=fg_red;
		cf->fg_green=fg_green;
		cf->fg_blue=fg_blue;
		cf->bg_red=bg_red;
		cf->bg_green=bg_green;
		cf->bg_blue=bg_blue;
		g_free(fontname);
		g_free(charset);
	}
	fclose(f);
}

