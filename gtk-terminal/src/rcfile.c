/*
 * gtk-terminal 
 * Author: Dave Young <lonelypenguin@gmail.com> 
 *
 * This software is released under the GNU General Public License (GNU GPL).
 * Please read the included file COPYING for more information.
 * This software comes with no warranty of any kind, use at your own risk!
 */


#include "gtk-terminal.h"
#include "rcfile.h"
#include "util.h"

static gchar * rcfile_path(void)
{
  	gchar *path = NULL;
  	const gchar *home_dir;

  	home_dir = (gchar *)get_home_dir ();
  	if (home_dir){
      		path = g_build_filename (home_dir,RCFILE, NULL);
	}

	g_free((gpointer)home_dir);
	return path;
}

/*
 * line write/parse routines
 */ 

gchar *quoted_value(const gchar *text)
{
	const gchar *ptr;
	gint i = 0;
	gint len = strlen(text);

	if (len == 0) return NULL;

	while (i < len && text[i] !='"') i++;
	if (text[i] == '"'){
		gint j;
		i++;
		ptr = text + i;
		j = i;
		while (j < len && text[j] !='"') j++;
		if (text[j] == '"'){
			if (j - i > 0)
				return g_strndup(ptr, j - i);
		}
	}
	return NULL;
}

static void write_char_option(FILE *f, gchar *label, gchar *text)
{
	if (text)
		fprintf(f,"%s: \"%s\"\n", label, text);
	else
		fprintf(f,"%s: \n", label);
}

static gchar *read_char_option(FILE *f, gchar *option, gchar *label, gchar *value)
{
	if (strcasecmp(option, label) == 0){
		return value;
	}
	return NULL;
}

static void write_int_option(FILE *f, gchar *label, gint n)
{
	fprintf(f,"%s: \"%d\"\n\n", label, n);
}

static gint read_int_option(FILE *f, gchar *option, gchar *label, gchar *value)
{
	gint vaint;

	vaint=atoi(value);
	
	if (strcasecmp(option, label) == 0){
		g_free(value);
		return vaint;
	}
	return -1;
}

static void write_bool_option(FILE *f, gchar *label, gboolean bol)
{
	if(bol)
		fprintf(f,"%s: \"TRUE\"\n\n", label);
	else
		fprintf(f,"%s: \"FALSE\"\n\n", label);
}

static gint read_bool_option(FILE *f,gchar *option, gchar *label, gchar *value , gboolean * bol)
{
	if (strcasecmp(option, label) == 0){
		if(strncmp(value,"TRUE",4))
			*bol=FALSE;
		else
			*bol=TRUE;
		return 0;
	}
	return 1;
}

/*
 * save configuration
 */ 

void save_options(confinfo * cf)
{
	FILE *f;
	gchar *rc_path;

	rc_path = rcfile_path();

	if(!rc_path)
		return;

	f = fopen(rc_path, "w");
	g_free(rc_path);

	if (!f){
		g_print(_("error saving config file: %s\n"), rc_path);
		return;
	}

	fprintf(f,"#%%$*gtk-terminal config file\n");
	fprintf(f,"\n");
	fprintf(f,"# Note: This file is autogenerated. Options can be changed here,\n");
	fprintf(f,"#       but user comments and formatting will be lost.\n");
	fprintf(f,"\n");

	write_char_option(f, "fontname", cf->fontname);
	fprintf(f,"\n");
	write_char_option(f, "charset", cf->charset);
	fprintf(f,"\n");
	write_int_option(f, "fg_red", cf->fg_red);
	fprintf(f,"\n");
	write_int_option(f, "fg_green", cf->fg_green);
	fprintf(f,"\n");
	write_int_option(f, "fg_blue", cf->fg_blue);
	fprintf(f,"\n");
	write_int_option(f, "bg_red", cf->bg_red);
	fprintf(f,"\n");
	write_int_option(f, "bg_green", cf->bg_green);
	fprintf(f,"\n");
	write_int_option(f, "bg_blue", cf->bg_blue);
	fprintf(f,"\n");
/*
	write_bool_option(f, "layout_view_as_icons", layout_view_icons);
	write_int_option(f, "scroll_reset_method", scroll_reset_method);
*/
	fprintf(f,"#%%$*gtk-terminal config file\n");
	fclose(f);
}

/*
 *-----------------------------------------------------------------------------
 * load configuration (public)
 *-----------------------------------------------------------------------------
 */ 

void load_options(confinfo *cf)
{
	FILE *f;
	gchar *rc_path;
	gchar s_buf[1024];
	gchar *s_buf_ptr;
	gchar * tmp;
	gchar option[1024]={'0',};
	gchar value[1024]={'0',};
	gchar * va=NULL;
	gint i,j,len;
	gchar * fontname=NULL;
	gchar * charset=NULL;
	gint fg_red=-1,fg_green=-1,fg_blue=-1,bg_red=-1,bg_green=-1,bg_blue=-1;

	rc_path = rcfile_path();

	if(!rc_path)
		return;

      	if (!g_file_test (rc_path, G_FILE_TEST_EXISTS)){
	 	g_free (rc_path);
		return;
	}

	f = fopen(rc_path,"r");
	g_free(rc_path);

	if (!f)
		return;

	while (fgets(s_buf,1024,f)){
		if (s_buf[0]=='#') {
//			if(!(s_buf[1]=='%' && s_buf[2]=='$' && s_buf[3]=='*'))
//				return;
			continue;
		}
		if (s_buf[0]=='\n') continue;
		i=j=0;
		len=strlen(s_buf);
		while(s_buf[i]==' ' || s_buf[i] =='\t')i++;
		j=i;
		tmp=s_buf+i;
		while(s_buf[j]!=':')j++;
		memset(option,0,sizeof(option));
		memset(value,0,sizeof(value));
		strncpy(option,tmp,j-i);
		s_buf_ptr= s_buf+j;
		strncpy(value,s_buf_ptr,strlen(s_buf_ptr));
		va = quoted_value(value);
		if(!va)
			continue;

		if(!fontname){
			fontname = read_char_option(f, option,"fontname", va);
			if(fontname)
				continue;
		}
		if(!charset){
			charset = read_char_option(f, option,"charset", va);
			if(charset)
				continue;
		}
		if(fg_red == -1){
			fg_red = read_int_option(f, option,"fg_red", va);
			if(fg_red!=-1)
				continue;
		}
		if(fg_green == -1){
			fg_green= read_int_option(f, option,"fg_green", va);
			if(fg_green!=-1){
				continue;
			}
		}
		if(fg_blue == -1){
			fg_blue = read_int_option(f, option,"fg_blue", va);
			if(fg_blue!=-1){
				continue;
			}
		}
		if(bg_red == -1){
			bg_red = read_int_option(f, option,"bg_red", va);
			if(bg_red!=-1){
				continue;
			}
		}
		if(bg_green == -1){
			bg_green= read_int_option(f, option,"bg_green", va);
			if(bg_green!=-1){
				continue;
			}
		}
		if(bg_blue == -1){
			bg_blue = read_int_option(f, option,"bg_blue", va);
			if(bg_blue!=-1){
				continue;
			}
		}
			
		if(va)
			g_free(va);
/*
		layout_view_tree = read_bool_option(f, option,
			"layout_view_as_tree", value, layout_view_tree);
		max_window_size = read_int_option(f, option,
			"max_window_size", value, max_window_size);
*/
	}
	if(fontname){
		int len;
	
		len=(strlen(fontname)>sizeof(cf->fontname))?sizeof(cf->fontname):strlen(fontname);
		memset(cf->fontname,0,sizeof(cf->fontname));
		strncpy(cf->fontname,fontname,len);
		g_free(fontname);
	}
	if(charset){
		int len;

		len=(strlen(charset)>sizeof(cf->charset))?sizeof(cf->charset):strlen(charset);
		memset(cf->charset,0,sizeof(cf->charset));
		strncpy(cf->charset,charset,len);
		g_free(charset);
	}
	if((fg_red !=-1) &&
			(fg_green !=-1)	&&
			(fg_blue !=-1) &&
			(bg_red !=-1) &&
			(bg_green !=-1) &&
			(bg_blue !=-1)) { 
		cf->fg_red=fg_red;
		cf->fg_green=fg_green;
		cf->fg_blue=fg_blue;
		cf->bg_red=bg_red;
		cf->bg_green=bg_green;
		cf->bg_blue=bg_blue;
	}
	
	fclose(f);
}

